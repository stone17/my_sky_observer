<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astro Framing Assistant</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <style>
        :root { --pico-spacing: 1rem; }
        html, body { height: 100%; overflow: hidden; }
        body { display: flex; flex-direction: column; }
        #app { display: flex; flex-direction: column; height: 100%; }
        .app-header { padding: 0.75rem var(--pico-spacing); border-bottom: 1px solid var(--pico-muted-border-color); flex-shrink: 0; display: flex; gap: var(--pico-spacing); align-items: center; flex-wrap: wrap; }
        .header-item { cursor: pointer; padding: 0.25rem 0.5rem; border-radius: var(--pico-border-radius); }
        .header-item:hover { background-color: var(--pico-muted-background-color); }
        .header-item kbd { background: none; border: none; padding: 0; font-size: 0.8em; color: var(--pico-contrast); }
        main { flex-grow: 1; display: grid; grid-template-columns: 350px 1fr; overflow: hidden; }
        .sidebar { display: flex; flex-direction: column; padding: var(--pico-spacing); overflow-y: auto; border-right: 1px solid var(--pico-muted-border-color); }
        .results-container { flex-grow: 1; overflow-y: auto; min-height: 0; }
        .results-list { list-style: none; padding: 0; margin: 0; }
        .results-list li { padding: 0.75rem; border-radius: var(--pico-border-radius); cursor: pointer; border-bottom: 1px solid var(--pico-card-border); }
        .results-list li:hover { background-color: var(--pico-muted-background-color); }
        .results-list li.selected { background-color: var(--pico-primary-background); color: var(--pico-primary-inverse); }
        .results-list li small { color: var(--pico-muted-color); }
        li.selected small { color: var(--pico-primary-inverse); }
        .status-icon { margin-right: 0.5em; }
        .detail-view { display: flex; flex-direction: column; gap: var(--pico-spacing); padding: var(--pico-spacing); overflow: hidden; }
        .image-container { position: relative; display: flex; align-items: center; justify-content: center; flex-grow: 1; min-height: 0; width: 100%; overflow: hidden; background-color: #111; border-radius: var(--pico-border-radius); cursor: grab; }
        .image-container:active { cursor: grabbing; }
        .image-container [aria-busy] { position: absolute; }
        .transform-wrapper { position: relative; display: flex; align-items: center; justify-content: center; max-width: 100%; max-height: 100%; aspect-ratio: 1 / 1; transform-origin: center; transition: transform 0.1s ease-out; }
        .transform-wrapper img { width: 100%; height: 100%; border-radius: var(--pico-border-radius); user-select: none; pointer-events: none; }
        .fov-overlay { position: absolute; top: 50%; left: 50%; border: 1px solid rgba(255, 0, 0, 0.7); box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); pointer-events: none; }
        .chart { width: 100%; height: 210px; }
        .framing-controls { flex-shrink: 0; }
        .app-footer { padding: 0.5rem var(--pico-spacing); border-top: 1px solid var(--pico-muted-border-color); flex-shrink: 0; font-size: 0.9em; color: var(--pico-muted-color); display: flex; justify-content: space-between; align-items: center; }
        [hidden] { display: none !important; }
        .error-message { color: var(--pico-form-element-invalid-color); }
    </style>
</head>
<body>
    <div id="app">
        <header class="app-header">
            <div @click="isScopeModalOpen = true" class="header-item"><strong>Scope:</strong> <kbd>{{ settings.telescope.focal_length }} mm</kbd></div>
            <div @click="isCameraModalOpen = true" class="header-item"><strong>Camera:</strong> <kbd>{{ selectedCamera }}</kbd></div>
            <div class="header-item"><strong>FoV:</strong> <kbd>{{ currentFov }}</kbd></div>
            <div @click="isLocationModalOpen = true" class="header-item"><strong>Location:</strong> <kbd>{{ settings.location.latitude.toFixed(2) }}¬∞, {{ settings.location.longitude.toFixed(2) }}¬∞</kbd></div>
            <div @click="isCatalogModalOpen = true" class="header-item"><strong>Catalogs:</strong> <kbd>{{ settings.catalogs.join(', ').toUpperCase() || 'None' }}</kbd></div>
            <div @click="isFilterModalOpen = true" class="header-item"><strong>Filter</strong></div>
        </header>
        <main>
            <aside class="sidebar">
                <article v-if="selectedObject">
                    <div id="chart-detail" class="chart"></div>
                </article>
                <hr v-if="selectedObject">
                <div class="results-container">
                    <ul class="results-list">
                        <li v-for="obj in results" :key="obj.name" 
                            :class="{ selected: obj.name === selectedObjectName }" 
                            @click="selectObject(obj.name)"
                            :id="getResultId(obj.name)">
                            <strong><span class="status-icon" :title="obj.status">{{ statusIcon(obj.status) }}</span><span v-if="!(obj.hours_above_min > 0.5)" title="Low altitude or short viewing time">‚ö†Ô∏è </span>{{ obj.name }}</strong> <small>({{ obj.catalog }})</small><br>
                            <small>Time: {{ obj.hours_above_min }}h | Size: {{ obj.maj_ax }}' | Mag: {{ obj.mag }}</small>
                        </li>
                    </ul>
                </div>
            </aside>
            <section class="detail-view" v-if="selectedObject">
                <div class="image-container" @wheel.prevent="handleZoom" @mousedown.prevent="startDrag" @mousemove.prevent="doDrag" @mouseup="endDrag" @mouseleave="endDrag">
                    <span :aria-busy="!imageLoaded && selectedObject.image_url" :hidden="imageLoaded || !selectedObject.image_url"></span>
                    <p v-if="selectedObject.status === 'downloading'" style="position: absolute; color: var(--pico-muted-color);">Downloading from Sky Survey...</p>
                    <div class="transform-wrapper" :style="{ transform: `scale(${zoom})` }">
                        <img v-if="selectedObject.image_url" :src="selectedObject.image_url" :alt="selectedObject.name" @load="onImageLoad" @error="onImageError" :hidden="!imageLoaded">
                        <div v-if="imageLoaded" class="fov-overlay" 
                            :style="{ 
                                width: selectedObject.fov_rectangle.width_percent + '%', 
                                height: selectedObject.fov_rectangle.height_percent + '%',
                                transform: `translate(calc(-50% + ${overlayX}px), calc(-50% + ${overlayY}px)) rotate(${rotation}deg)`
                            }">
                        </div>
                    </div>
                </div>
                <article class="framing-controls">
                    <div style="display: grid; grid-template-columns: auto 1fr; align-items: center; gap: 1rem;">
                        <label for="rotation" style="margin: 0;">Rotation: {{ rotation }}¬∞</label>
                        <input type="range" min="0" max="360" v-model.number="rotation" id="rotation">
                    </div>
                </article>
            </section>
            <section v-else class="detail-view"><article><p>Configure your equipment in the header to begin. Objects will load automatically.</p></article></section>
        </main>
        <footer class="app-footer">
            <div>
                <progress v-if="footerStatus.showProgress" :value="footerStatus.progressValue" :max="footerStatus.progressMax || 1" style="width: 150px; display: inline-block;"></progress>
                <span :class="{'error-message': validationError && !isLoading}">{{ footerStatus.text }}</span>
            </div>
            <button @click="fetchObjects" :disabled="isLoading">Reload Object Images</button>
        </footer>
        <dialog :open="isFilterModalOpen">
            <article>
                <header><a href="#close" aria-label="Close" class="close" @click.prevent="isFilterModalOpen = false"></a><strong>Filter & Sort Settings</strong></header>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--pico-spacing);">
                    <label>Min Altitude
                        <input type="number" step="1" v-model.number="settings.min_altitude">
                    </label>
                    <label>Sort By
                        <select v-model="sortKey">
                            <option value="time">Time Above Alt</option>
                            <option value="size">Size</option>
                            <option value="brightness">Brightness</option>
                        </select>
                    </label>
                </div>
            </article>
        </dialog>
        <dialog :open="isScopeModalOpen">
            <article>
                <header><a href="#close" aria-label="Close" class="close" @click.prevent="isScopeModalOpen = false"></a><strong>Telescope Settings</strong></header>
                <label>Focal Length (mm)<input type="number" v-model.number="settings.telescope.focal_length"></label>
            </article>
        </dialog>
        <dialog :open="isCameraModalOpen">
            <article>
                <header><a href="#close" aria-label="Close" class="close" @click.prevent="isCameraModalOpen = false"></a><strong>Camera Settings</strong></header>
                <label>Camera Preset<select v-model="selectedCamera"><option>Custom</option><option v-for="(cam, name) in cameras" :value="name">{{ name }}</option></select></label>
                <label>Sensor Width (mm)<input type="number" step="0.01" v-model.number="settings.camera.sensor_width" :disabled="selectedCamera !== 'Custom'"></label>
                <label>Sensor Height (mm)<input type="number" step="0.01" v-model.number="settings.camera.sensor_height" :disabled="selectedCamera !== 'Custom'"></label>
            </article>
        </dialog>
        <dialog :open="isLocationModalOpen">
            <article>
                <header><a href="#close" aria-label="Close" class="close" @click.prevent="isLocationModalOpen = false"></a><strong>Location Settings</strong></header>
                <label>Location Search<input type="search" placeholder="e.g., Lund" v-model="citySearchQuery" @keydown.enter.prevent="searchCity"></label>
                <button type="button" class="secondary" @click="searchCity" :aria-busy="isSearchingCity">Search</button>
                <hr>
                <label>Latitude (¬∞N)<input type="number" step="0.0001" v-model.number="settings.location.latitude"></label>
                <label>Longitude (¬∞E)<input type="number" step="0.0001" v-model.number="settings.location.longitude"></label>
            </article>
        </dialog>
        <dialog :open="isCityModalOpen">
            <article>
                <header><a href="#close" aria-label="Close" class="close" @click.prevent="isCityModalOpen = false"></a><h5>Select a Location</h5></header>
                <p v-if="citySearchResults.length === 0">No results found for "{{ citySearchQuery }}".</p>
                <ul v-else style="list-style: none; padding: 0; margin: 0;"><li v-for="city in citySearchResults" :key="city.latitude + city.longitude" style="margin-bottom: 0.5rem;"><button class="outline" style="width: 100%; text-align: left;" @click="selectCity(city)"><strong>{{ city.name }}</strong><br><small>{{ city.admin1 }}{{ city.admin1 ? ', ' : '' }}{{ city.country }}</small></button></li></ul>
            </article>
        </dialog>
        <dialog :open="isCatalogModalOpen">
            <article>
                <header><a href="#close" aria-label="Close" class="close" @click.prevent="isCatalogModalOpen = false"></a><strong>Select Catalogs</strong></header>
                <fieldset>
                    <label><input type="checkbox" v-model="settings.catalogs" value="messier"> Messier</label>
                    <label><input type="checkbox" v-model="settings.catalogs" value="ngc"> NGC</label>
                </fieldset>
            </article>
        </dialog>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js" charset="utf-8"></script>
    
    <script>
        const { createApp, ref, reactive, watch, computed, onMounted, onUnmounted, nextTick } = Vue;

        const app = createApp({
            setup() {
                const settings = reactive({
                    telescope: { focal_length: 135 }, camera: { sensor_width: 23.5, sensor_height: 15.7 },
                    location: { latitude: 55.70, longitude: 13.19 }, catalogs: ['messier'], min_altitude: 30
                });
                const cameras = ref({});
                const results = ref([]);
                const isLoading = ref(false);
                const serverState = ref('idle'); 
                const validationError = ref('');
                const selectedObjectName = ref(null);
                const imageLoaded = ref(false);
                const totalToProcess = ref(0);
                const processingProgress = ref(0);
                const sortKey = ref('time');
                const appReady = ref(false);
                let eventSource = null;
                let saveTimeout;
                let reloadTimeout;

                const isScopeModalOpen = ref(false), isCameraModalOpen = ref(false), isLocationModalOpen = ref(false), isCityModalOpen = ref(false), isCatalogModalOpen = ref(false), isFilterModalOpen = ref(false);
                const citySearchQuery = ref(''), citySearchResults = ref([]), isSearchingCity = ref(false);
                const rotation = ref(0), isDragging = ref(false), dragStart = reactive({ x: 0, y: 0 }), initialOverlay = reactive({ x: 0, y: 0 }), overlayX = ref(0), overlayY = ref(0), zoom = ref(1);
                const twilightPeriods = ref({}), lastUpdatedTime = ref('never');

                const selectedObject = computed(() => results.value.find(o => o.name === selectedObjectName.value));

                const selectedCamera = computed({
                    get() {
                        const { sensor_width, sensor_height } = settings.camera;
                        for (const name in cameras.value) { if (cameras.value[name].width === sensor_width && cameras.value[name].height === sensor_height) return name; }
                        return 'Custom';
                    },
                    set(name) { if (name && name !== 'Custom' && cameras.value[name]) Object.assign(settings.camera, {width: cameras.value[name].width, height: cameras.value[name].height}); }
                });

                const currentFov = computed(() => {
                    const { focal_length, sensor_width, sensor_height } = {...settings.telescope, ...settings.camera};
                    if (!focal_length || focal_length <= 0) return 'N/A';
                    const fov_w = (sensor_width / focal_length) * (180 / Math.PI);
                    const fov_h = (sensor_height / focal_length) * (180 / Math.PI);
                    return `${fov_w.toFixed(2)}¬∞ x ${fov_h.toFixed(2)}¬∞`;
                });

                const footerStatus = computed(() => {
                    if (serverState.value === 'processing') {
                        return { text: `Processing ${processingProgress.value} of ${totalToProcess.value} targets...`, showProgress: true, progressValue: processingProgress.value, progressMax: totalToProcess.value };
                    }
                    if (serverState.value === 'downloading') {
                        return { text: `Downloading images...`, showProgress: false };
                    }
                    if (validationError.value) return { text: validationError.value, showProgress: false };
                    return { text: `Found top ${results.value.length} objects. Last updated: ${lastUpdatedTime.value}`, showProgress: false };
                });
                
                const statusIcon = (status) => ({ 'queued': 'üïí', 'downloading': 'üì•', 'cached': '‚úÖ', 'error': '‚ùå' }[status] || '');
                const getResultId = (name) => `result-${name.replace(/[^a-zA-Z0-9]/g, '_')}`;

                const saveSettings = () => {
                    clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => { fetch('/api/settings', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(settings) }); }, 500);
                };
                
                const fetchObjects = () => {
                    validationError.value = '';
                    if (settings.telescope.focal_length <= 0) { validationError.value = 'Focal Length must be > 0.'; return; }
                    if (!settings.catalogs || settings.catalogs.length === 0) {
                        results.value = []; totalToProcess.value = 0;
                        validationError.value = 'Please select at least one catalog.'; return;
                    }
                    if (isLoading.value) { return; }
                    if (eventSource) eventSource.close();
                    
                    isLoading.value = true;
                    serverState.value = 'processing';
                    results.value = []; totalToProcess.value = 0; processingProgress.value = 0; selectedObjectName.value = null;

                    const params = new URLSearchParams({
                        focal_length: settings.telescope.focal_length, sensor_width: settings.camera.sensor_width, sensor_height: settings.camera.sensor_height,
                        latitude: settings.location.latitude, longitude: settings.location.longitude, catalogs: settings.catalogs.join(','), min_altitude: settings.min_altitude,
                        sort_key: sortKey.value
                    });
                    
                    eventSource = new EventSource(`/api/stream-objects?${params.toString()}`);
                    eventSource.addEventListener('total', (event) => { totalToProcess.value = parseInt(event.data, 10); });
                    eventSource.addEventListener('processing_progress', (event) => { processingProgress.value = parseInt(event.data, 10); });
                    eventSource.addEventListener('twilight_info', (event) => { twilightPeriods.value = JSON.parse(event.data); });
                    eventSource.addEventListener('object_data', (event) => { results.value.push(JSON.parse(event.data)); });
                    eventSource.addEventListener('image_status', (event) => {
                        serverState.value = 'downloading';
                        const update = JSON.parse(event.data);
                        const obj = results.value.find(o => o.name === update.name);
                        if (obj) {
                            obj.status = update.status;
                            if (update.url) obj.image_url = update.url;
                        }
                    });

                    eventSource.addEventListener('close', () => {
                        eventSource.close();
                        isLoading.value = false;
                        serverState.value = 'idle';
                        lastUpdatedTime.value = new Date().toLocaleTimeString();
                    });
                    eventSource.onerror = (err) => { validationError.value = 'Error fetching data. Check server logs.'; eventSource.close(); isLoading.value = false; serverState.value = 'idle'; };
                };

                const renderSelectedChart = (obj) => {
                    const chartDiv = document.getElementById('chart-detail');
                    if (!obj || !chartDiv) return;
                    const times = obj.altitude_graph.map(p => new Date(p.time));
                    const altitudes = obj.altitude_graph.map(p => p.altitude);
                    const data = [{ x: times, y: altitudes, type: 'scatter', mode: 'lines', line: { color: '#00d1b2' } }];
                    const layout = {
                        title: { text: `Altitude of ${obj.name} (¬∞)`, font: { size: 12 } },
                        paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', font: { color: '#ccc' },
                        margin: { l: 30, r: 10, b: 30, t: 40, pad: 4 }
                    };
                    Plotly.react(chartDiv, data, layout, {responsive: true, displayModeBar: false});
                };
                
                const handleKeyDown = (e) => {
                    if (results.value.length === 0 || !selectedObjectName.value) return;
                    const currentIndex = results.value.findIndex(o => o.name === selectedObjectName.value);
                    let newIndex = currentIndex;
                    if (e.key === 'ArrowUp' && currentIndex > 0) newIndex--;
                    else if (e.key === 'ArrowDown' && currentIndex < results.value.length - 1) newIndex++;
                    if (newIndex !== currentIndex) selectObject(results.value[newIndex].name);
                };
                
                const searchCity = async () => { if (citySearchQuery.value.length < 2) return; isSearchingCity.value = true; citySearchResults.value = []; try { const response = await fetch(`/api/geocode?city=${encodeURIComponent(citySearchQuery.value)}`); citySearchResults.value = await response.json(); isCityModalOpen.value = true; } catch(e) { console.error(e); } finally { isSearchingCity.value = false; } };
                const selectCity = (city) => { settings.location.latitude = city.latitude; settings.location.longitude = city.longitude; isCityModalOpen.value = false; isLocationModalOpen.value = false; citySearchQuery.value = ''; };
                const onImageLoad = () => { imageLoaded.value = true; };
                const onImageError = () => { 
                    imageLoaded.value = false; 
                    if (selectedObject.value) {
                        selectedObject.value.status = 'error'; 
                        console.error('Failed to load image for object:', selectedObject.value);
                    }
                };
                const selectObject = (name) => { if (selectedObjectName.value === name) return; selectedObjectName.value = name; overlayX.value = 0; overlayY.value = 0; zoom.value = 1; rotation.value = 0; imageLoaded.value = false; };
                const startDrag = (event) => { isDragging.value = true; dragStart.x = event.clientX; dragStart.y = event.clientY; initialOverlay.x = overlayX.value; initialOverlay.y = overlayY.value; };
                const doDrag = (event) => { if (!isDragging.value) return; overlayX.value = initialOverlay.x + ((event.clientX - dragStart.x) / zoom.value); overlayY.value = initialOverlay.y + ((event.clientY - dragStart.y) / zoom.value); };
                const endDrag = () => { isDragging.value = false; };
                const handleZoom = (event) => { zoom.value = Math.max(0.5, Math.min(zoom.value - event.deltaY * 0.001, 5)); };
                
                onMounted(async () => {
                    const response = await fetch('/api/settings');
                    const savedSettings = await response.json();
                    if (savedSettings) Object.assign(settings, savedSettings);
                    const camResponse = await fetch('/api/presets');
                    cameras.value = (await camResponse.json()).cameras;
                    window.addEventListener('keydown', handleKeyDown);
                    
                    fetchObjects();
                    appReady.value = true;
                });

                onUnmounted(() => { window.removeEventListener('keydown', handleKeyDown); if (eventSource) eventSource.close(); });
                
                watch(settings, saveSettings, { deep: true });

                watch([
                    () => settings.telescope, () => settings.camera, () => settings.location,
                    () => settings.catalogs, () => settings.min_altitude, () => sortKey.value
                ], () => {
                    if (!appReady.value) return;
                    clearTimeout(reloadTimeout);
                    reloadTimeout = setTimeout(() => { fetchObjects(); }, 500);
                }, { deep: true });

                watch(selectedObject, (newObj) => { if (newObj) nextTick(() => renderSelectedChart(newObj)); });

                watch(selectedObjectName, (newName) => {
                    nextTick(() => {
                        const el = document.getElementById(getResultId(newName));
                        if (el) el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    });
                });

                watch(results, (newList) => {
                    if (!selectedObjectName.value && newList.length > 0) {
                        selectObject(newList[0].name);
                    }
                });
                
                return {
                    settings, cameras, results, isLoading, serverState, validationError, selectedObjectName, imageLoaded, totalToProcess, processingProgress,
                    sortKey, isScopeModalOpen, isCameraModalOpen, isLocationModalOpen, isCityModalOpen, isCatalogModalOpen, isFilterModalOpen,
                    citySearchQuery, citySearchResults, isSearchingCity, rotation, overlayX, overlayY, zoom,
                    selectedObject, currentFov, footerStatus,
                    fetchObjects, statusIcon, selectObject, searchCity, selectCity, handleKeyDown, getResultId,
                    onImageLoad, onImageError, startDrag, doDrag, endDrag, handleZoom
                };
            }
        });
        
        app.mount('#app');
    </script>
</body>
</html>